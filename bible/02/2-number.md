## 2-1 数值类型

- rust和其他语言一样，数值类型支持`+-*/`。
- rust支持***运算符重载*** 
  - 不仅仅是数值类型，Rust 也允许在复杂类型上定义运算符，例如在自定义类型上定义 + 运算符，这种行为被称为运算符重载。

### 整数类型

- 整数是没有小数部分的数字。之前使用过的 i32 类型，表示有符号的 32 位整数（ i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）。下表显示了 Rust 中的内置的整数类型：
  |  长度  | 有符号 | 无符号 |
  |  ----  | ----  | ---- |
  | 8bit   | i8 | u8 |
  | 16bit  | i16 | u16 |
  | 32bit  | i32 | u32 |
  | 64bit  | i64 | u64 |
  | 128bit  | i128 | u128 |
  | cpu架构决定  | isize | usize |
  - 这里需要注意，
    - 多了128位的有符号和无符号，其他语言基本没有这么长位数的。
    - i/usize 类型依赖cpu的位数，如32位cpu则32位，64位cpu则64位。那么这个不具备可移植性，需要注意。
- 整数字面量，可以用如下的形式：
  | 数字字面量 | 示例 |
  |  ----  | ----  |
  | 十进制 | 98_222 |
  | 十六进制 | 0xff |
  | 八进制 | 0o77 |
  | 二进制 | 0b1111_0000 |
  | 字节 (仅限于 u8) | b'A' |

- ***最佳实践***
  - Rust 整型默认使用 i32，例如 let i = 1，那 i 就是 i32 类型，因此你可以首选它，同时该类型也往往是性能最好的。
  - isize 和 usize 的主要应用场景是用作集合的索引。

- 整数溢出
  - rust这里在debug和release编译的时候的效果不同
    - debug会检测溢出，如果溢出则panic
    - release不会检测溢出，溢出则进位，即：
      - Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值
  - 通常可以采用这些方法，来检测溢出。
    - 使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
    - 如果使用 checked_* 方法时发生溢出，则返回 None 值
    - 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
    - 使用 saturating_* 方法使值达到最小值或最大值

### 浮点类型

- rust支持两种浮点类型: 
  - 单精度: `f32`
  - 双精度: `f64`, 如果不指定，则默认为双精度。
- 浮点数在做相等性判断比较特殊，其他语言也是一样。
  - 可以考虑用 `(a-b) < 0.000001`的方式。具体后面的小数位数，取决于你的精度。
  - rust中的hashmap的key需要类型支持相当性操作，而浮点型没有实现相等性，也就意味着hashmap的key不支持浮点型。
- NaN: 未定义的行为
  - 当给负数开平方根的时候，数学上会出现未定义的行为，这时rust会返回nan，注意，nan是不可比较的。
