## 2.1 变量绑定与解构

- 变量运行设定为不可变的、可变的，有点类似于`c++`的`const`，注意，rust中也有常量，和不可变的变量并不相同，这点需要注意。

### 变量绑定

- 类似于其他语言的变量赋值，而rust叫做变量绑定：
    ```let <var> = <value>;```
- 为何不用赋值而用绑定呢（其实你也可以称之为赋值，但是绑定的含义更清晰准确）？这里就涉及 Rust 最核心的原则——所有权，简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人（聪明的读者应该能猜到，在这种情况下，该对象之前的主人就会丧失对该对象的所有权）
- 有点像`c++`的智能指针。

### 变量可变性

- Rust 的变量在默认情况下是***不可变的***
- 这是 Rust 团队为我们精心设计的语言特性之一，让我们编写的代码更安全，性能也更好。
- 当然你可以通过 mut 关键字让变量变为可变的，让设计更灵活。
- ***最佳实践***:
  - 选择可变还是不可变，更多的还是取决于你的使用场景，例如不可变可以带来安全性，但是丧失了灵活性和性能（如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配）。而可变变量最大的好处就是使用上的灵活性和性能上的提升。
  - 通常大对象的复制成本非常高，可以考虑使用mut变量，而小对象则可以考虑不可变变量。
  
### 使用下划线开头忽略未使用的变量

- 这属于rust的独裁者了，有点类似于go的`_`, 不使用的变量，采用特殊的语法来规避警告，但是go就更加强烈了，直接编译失败，而rust声明了未使用则只是警告而已。
- 通常采用下划线开头来消除警告。
- 个人认为，通常项目中不应该存在这种代码。(其实意味着这个变量并未使用)。
- 重要的说三遍：
  - ***只是警告，编译能通过。***
  
### 变量解构

- 可以理解为多重赋值，更加复杂的需要理解模式匹配相关的章节。这里并不深入研究。

### 常量

- 常量与不可变变量存在区别：
  - 常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确定它的值。
  - 常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。
    - Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，如果不按照这个来，编译会给出警告，然后编译成功。
  - 常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。
- ***最佳实践***
  - 在实际使用中，最好将程序中用到的硬编码值都声明为常量，对于代码后续的维护有莫大的帮助。如果将来需要更改硬编码的值，你也只需要在代码中更改一处即可。

### 变量遮蔽(shadowing)

- 即作用域内部的会屏蔽掉外部的变量。这个和其他语言基本一致。
- 变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。
  - 允许遮蔽后，类型不同。如下示例：
  ```rust
  // 字符串类型
  let spaces = "   ";
  // usize数值类型
  let spaces = spaces.len();
  ```